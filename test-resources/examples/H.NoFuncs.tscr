Subst[body; old; new].
AndMap[f; xs].
Apply[f; x].
IsSymbol[].
IsEqual[x; y].

//Lambda application
scm'((lambda (\x) \body) \arg)' &Standard[]: Subst[\body; \x; \arg] &Subst[];

//Currying
&Curry[];

//Eval
E[scm'(\x \y)']: scm'(\(E[\x]) \(E[\y]))';

//Helpers
AndMap[\f; Scheme_Nil[]]: Scheme_Nil[];
AndMap[\f; Scheme_Cons[\x; \xs]] &IsTrue[x: Apply[\f; \x]]: AndMap[\f; \xs];
AndMap[\; Scheme_Cons[\; \]]: False[];
Apply[IsSymbol[]; Scheme_Symbol[\]]: True[];
Apply[IsSymbol[]; \]: False[];
IsEqual[\x; \x]: True[];
IsEqual[\; \]: False[];

//Groups
&Subst[].
---
Subst[\old; \old; \new]: \new;
Subst[scm'(lambda (\old) \body)'; \old; \] &Standard[x: \old]: scm'(lambda (\old) \body)';
Subst[scm'(lambda (\x) \body)'; \old; \new] &Standard[]: scm'(lambda (\x) \(Subst[\body; \old; \new]))';
Subst[scm'(\f \x)'; \old; \new]: scm'(\(Subst[\f; \old; \new]) \(Subst[\x; \old; \new]))';
Subst[\body; \; \]: \body;
&FullRecurse[];

&Curry[].
---
scm'(lambda (\x \x2 . \xs) \body)': scm'(lambda (\x) (lambda (\x2 . \xs) \body))';
scm'(\f \arg . \args)' &NonEmpty[xs: \args] &IsFalse[x: IsEqual[\f; scm'lambda']]: scm'((\f \arg) . \args)';
&FullRecurse[];

&FullRecurse[].
---
E[scm'(\x \y)']: scm'(\(E[\x]) \(E[\y]))';
E[scm'(lambda (\x) \body)']: scm'(lambda (\x) \(E[\body]))';

&Standard[x; x2; xs].
---
\x: Scheme_Symbol[\];
Apply[IsSymbol[]; \x2]: True[];
AndMap[IsSymbol[]; \xs]: True[];
&NonEmpty[];

&NonEmpty[xs].
---
\xs: Scheme_Cons[\; \];

&IsTrue[x].
---
\x: True[];

&IsFalse[x].
---
\x: False[];
